{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  useCallback,\n  useReducer,\n  Dispatch,\n  Reducer,\n  ReducerState,\n  ReducerAction,\n} from 'react';\n\ntype AsyncFunctions<AsyncAction, Action> = AsyncAction extends {\n    type: infer Types;\n} ? Types extends string ? {\n    [T in Types]: AsyncAction extends infer A ? A extends {\n        type: T;\n    } ? (d: Dispatch<Action>) => (a: A) => Promise<void> : never : never;\n} : never : never;\n\nexport function useReducerAsync<R extends Reducer<any, any>, I, AsyncAction, OuterAction>(\n  reducer: R,\n  initializerArg: I,\n  initializer: (arg: I) => ReducerState<R>,\n  asyncFunctions: AsyncFunctions<AsyncAction, ReducerAction<R>>,\n): Exclude<OuterAction, AsyncAction | ReducerAction<R>> extends never ?\n  [ReducerState<R>, Dispatch<OuterAction>] : never;\n\n/**\n * useReducer with async action functions\n * @example\n * import { useReducerAsync } from 'use-reducer-async';\n *\n * const asyncActions = {\n *   SLEEP: dispatch => async (action) => {\n *     dispatch({ type: 'START_SLEEP' });\n *     await new Promise(r => setTimeout(r, action.ms));\n *     dispatch({ type: 'END_SLEEP' });\n *   },\n *   FETCH: dispatch => async (action) => {\n *     dispatch({ type: 'START_FETCH' });\n *     try {\n *       const response = await fetch(action.url);\n *       const data = await response.json();\n *       dispatch({ type: 'FINISH_FETCH', data });\n *     } catch (error) {\n *       dispatch({ type: 'ERROR_FETCH', error });\n *     }\n *   },\n * };\n * const [state, dispatch] = useReducerAsync(reducer, initialState, asyncActions);\n */\nexport function useReducerAsync<R extends Reducer<any, any>, AsyncAction, OuterAction>(\n  reducer: R,\n  initialState: ReducerState<R>,\n  asyncFunctions: AsyncFunctions<AsyncAction, ReducerAction<R>>,\n): Exclude<OuterAction, AsyncAction | ReducerAction<R>> extends never ?\n  [ReducerState<R>, Dispatch<OuterAction>] : never;\n\nexport function useReducerAsync<R extends Reducer<any, any>, I, AsyncAction, OuterAction>(\n  reducer: R,\n  initializerArg: I | ReducerState<R>,\n  initializer: unknown,\n  asyncFunctions?: AsyncFunctions<AsyncAction, ReducerAction<R>>,\n): [ReducerState<R>, Dispatch<OuterAction>] {\n  const asyncFuncs = asyncFunctions || initializer as AsyncFunctions<AsyncAction, ReducerAction<R>>;\n  const [state, rawDispatch] = useReducer(\n    reducer,\n    initializerArg as any,\n    asyncFunctions && initializer as any,\n  );\n  const dispatch = useCallback((action: AsyncAction | ReducerAction<R>) => {\n    const { type } = (action || {}) as { type?: string };\n    const asyncFunc = (\n      (type && asyncFuncs[type]) || null\n    ) as (typeof action extends AsyncAction ?\n      (d: Dispatch<ReducerAction<R>>) => (a: typeof action) => Promise<void> : null);\n    if (asyncFunc) {\n      asyncFunc(rawDispatch)(action as AsyncAction);\n    } else {\n      rawDispatch(action as ReducerAction<R>);\n    }\n  }, [asyncFuncs]);\n  return [state, dispatch] as [ReducerState<R>, Dispatch<OuterAction>];\n}\n"],"names":["useReducerAsync","reducer","initializerArg","initializer","asyncFunctions","asyncFuncs","useReducer","rawDispatch","useCallback","action","type","asyncFunc"],"mappings":"6DAwDgBA,EACdC,EACAC,EACAC,EACAC,GAEA,IAAMC,EAAaD,GAAkBD,IACRG,EAC3BL,EACAC,EACAE,GAAkBD,GAHNI,OAiBd,MAAO,MAZUC,GAAY,SAACC,OACpBC,GAAUD,GAAU,IAApBC,KACFC,EACHD,GAAQL,EAAWK,IAAU,KAG5BC,EACFA,EAAUJ,EAAVI,CAAuBF,GAEvBF,EAAYE,KAEb,CAACJ"}