{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["import {\r\n  useCallback,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useReducer,\r\n  useRef,\r\n  Dispatch,\r\n  Reducer,\r\n  ReducerState,\r\n  ReducerAction,\r\n} from 'react';\r\n\r\nconst isClient = (\r\n  typeof window !== 'undefined'\r\n  && !/ServerSideRendering/.test(window.navigator && window.navigator.userAgent)\r\n);\r\n\r\nconst useIsomorphicLayoutEffect = isClient ? useLayoutEffect : useEffect;\r\n\r\nconst useAbortSignal = () => {\r\n  const abortController = useRef<AbortController>();\r\n  if (!abortController.current) {\r\n    abortController.current = new AbortController();\r\n  }\r\n  useEffect(() => {\r\n    const abort = () => {\r\n      (abortController.current as AbortController).abort();\r\n    };\r\n    return abort;\r\n  }, []);\r\n  return abortController.current.signal;\r\n};\r\n\r\nexport type AsyncActionHandlers<\r\n  R extends Reducer<any, any>,\r\n  AsyncAction extends { type: string }\r\n> = {\r\n  [T in AsyncAction['type']]: AsyncAction extends infer A ? A extends {\r\n    type: T;\r\n  } ? (s: {\r\n    dispatch: Dispatch<ReducerAction<R>>;\r\n    getState: () => ReducerState<R>;\r\n    signal: AbortSignal;\r\n  }) => (a: A) => Promise<void> : never : never;\r\n};\r\n\r\nexport function useReducerAsync<\r\n  R extends Reducer<any, any>,\r\n  I,\r\n  AsyncAction extends { type: string },\r\n  ExportAction extends AsyncAction | ReducerAction<R> = AsyncAction | ReducerAction<R>\r\n>(\r\n  reducer: R,\r\n  initializerArg: I,\r\n  initializer: (arg: I) => ReducerState<R>,\r\n  asyncActionHandlers: AsyncActionHandlers<R, AsyncAction>,\r\n): [ReducerState<R>, Dispatch<ExportAction>];\r\n\r\n/**\r\n * useReducer with async actions\r\n * @example\r\n * import { useReducerAsync } from 'use-reducer-async';\r\n *\r\n * const asyncActionHandlers = {\r\n *   SLEEP: ({ dispatch, getState, signal }) => async (action) => {\r\n *     dispatch({ type: 'START_SLEEP' });\r\n *     await new Promise(r => setTimeout(r, action.ms));\r\n *     dispatch({ type: 'END_SLEEP' });\r\n *   },\r\n *   FETCH: ({ dispatch, getState, signal }) => async (action) => {\r\n *     dispatch({ type: 'START_FETCH' });\r\n *     try {\r\n *       const response = await fetch(action.url);\r\n *       const data = await response.json();\r\n *       dispatch({ type: 'FINISH_FETCH', data });\r\n *     } catch (error) {\r\n *       dispatch({ type: 'ERROR_FETCH', error });\r\n *     }\r\n *   },\r\n * };\r\n * const [state, dispatch] = useReducerAsync(reducer, initialState, asyncActionHandlers);\r\n */\r\nexport function useReducerAsync<\r\n  R extends Reducer<any, any>,\r\n  AsyncAction extends { type: string },\r\n  ExportAction extends AsyncAction | ReducerAction<R> = AsyncAction | ReducerAction<R>\r\n>(\r\n  reducer: R,\r\n  initialState: ReducerState<R>,\r\n  asyncActionHandlers: AsyncActionHandlers<R, AsyncAction>,\r\n): [ReducerState<R>, Dispatch<ExportAction>];\r\n\r\nexport function useReducerAsync<\r\n  R extends Reducer<any, any>,\r\n  I,\r\n  AsyncAction extends { type: string },\r\n  ExportAction extends AsyncAction | ReducerAction<R> = AsyncAction | ReducerAction<R>\r\n>(\r\n  reducer: R,\r\n  initializerArg: I | ReducerState<R>,\r\n  initializer: unknown,\r\n  asyncActionHandlers?: AsyncActionHandlers<R, AsyncAction>,\r\n): [ReducerState<R>, Dispatch<ExportAction>] {\r\n  const signal = useAbortSignal();\r\n  const aaHandlers = (\r\n    asyncActionHandlers || initializer\r\n  ) as AsyncActionHandlers<R, AsyncAction>;\r\n  const [state, dispatch] = useReducer(\r\n    reducer,\r\n    initializerArg as any,\r\n    asyncActionHandlers && initializer as any,\r\n  );\r\n  const lastState = useRef(state);\r\n  useIsomorphicLayoutEffect(() => {\r\n    lastState.current = state;\r\n  }, [state]);\r\n  const getState = useCallback((() => lastState.current), []);\r\n  const wrappedDispatch = useCallback((action: AsyncAction | ReducerAction<R>) => {\r\n    const { type } = (action || {}) as { type?: AsyncAction['type'] };\r\n    const aaHandler = (\r\n      (type && aaHandlers[type]) || null\r\n    ) as (typeof action extends AsyncAction ? (s: {\r\n      dispatch: Dispatch<ReducerAction<R>>;\r\n      getState: () => ReducerState<R>;\r\n      signal: AbortSignal;\r\n    }) => (a: typeof action) => Promise<void> : null);\r\n    return aaHandler\r\n      ? aaHandler({ dispatch, getState, signal })(action as AsyncAction)\r\n      : dispatch(action as ReducerAction<R>);\r\n  }, [aaHandlers, getState, signal]);\r\n  return [state, wrappedDispatch];\r\n}\r\n"],"names":["useIsomorphicLayoutEffect","window","test","navigator","userAgent","useEffect","useLayoutEffect","useReducerAsync","reducer","initializerArg","initializer","asyncActionHandlers","abortController","signal","useRef","current","AbortController","abort","aaHandlers","useReducer","state","dispatch","lastState","getState","useCallback","wrappedDispatch","action","type","aaHandler"],"mappings":"oGAYA,IAKMA,EAJc,oBAAXC,QACH,sBAAsBC,KAAKD,OAAOE,WAAaF,OAAOE,UAAUC,WAGPC,EAAlBC,WA2E7BC,EAMdC,EACAC,EACAC,EACAC,GAEA,IAnFMC,EAmFAC,IAnFAD,EAAkBE,KACHC,UACnBH,EAAgBG,QAAU,IAAIC,iBAEhCX,EAAU,WAIR,OAHc,WACXO,EAAgBG,QAA4BE,UAG9C,IACIL,EAAgBG,QAAQF,QA0EzBK,EACJP,GAAuBD,IAECS,EACxBX,EACAC,EACAE,GAAuBD,GAHlBU,OAAOC,OAKRC,EAAYR,EAAOM,GACzBpB,EAA0B,WACxBsB,EAAUP,QAAUK,GACnB,CAACA,IACJ,IAAMG,EAAWC,EAAa,kBAAMF,EAAUP,SAAU,IAClDU,EAAkBD,EAAY,SAACE,OAC3BC,GAAUD,GAAU,IAApBC,KACFC,EACHD,GAAQT,EAAWS,IAAU,KAMhC,OAAOC,EACHA,EAAU,CAAEP,SAAAA,EAAUE,SAAAA,EAAUV,OAAAA,GAAhCe,CAA0CF,GAC1CL,EAASK,IACZ,CAACR,EAAYK,EAAUV,IAC1B,MAAO,CAACO,EAAOK"}